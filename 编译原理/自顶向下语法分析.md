# 一，自顶向下语法分析及面临的问题

# 1. 语法分析程序的功能 

语法分析时编译程序的核心部分，<font color = red>作用是按照程序语言的语法规则，从由词法分析输出的源程序符号串当中，去识别出各类语法成分，也就是说看看输入的符号串能否构成一个正确的句子。同时进行语法检查，输出程序内部的中间表示形式，譬如说语法树。为语义分析和代码的生成去做准备</font>。

由于正则表达式和正则文法它是等价的，但是它们的描述能力是有限的，而高级程序设计语言它的语法结构，适合用上下文无关文法来描述，因此，我们把上下文无关文法作为语法分析的基础，也就是说，这个规则是用上下文无关文法的产生式来定义的。

![image-20200516201753852](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\image-20200516201753852.png)

# 2.语法分析概述

自上而下：开始符号=>输入符号串

自底向上：开始符号   归约到   输入符号串

# 3.自上而下分析面临的问题



（1）构建过程：从文法开始符号出发，自上而下的为输入串建立一棵语法树，使语法树的末端结点与给定符号串相匹配。

（2）自顶向下分析方法的特点

* **分析过程是带有<font color = red>预测</font>的，对输入符号串要预测属于什么语法成分，然后根据该语法成分的文法建立语法树。**
* **分析过程是一种<font color = red>试探过程</font>，是尽一切办法(选用不同规则) 设法建立语法树的过程，由于是试探过程，故难免有失败， 所以分析过程需进行<font color = red>回溯</font>，因此我们也称这种方法是带回溯的自顶向下分析方法。**

（3）出现的问题

问题1：回溯

分析工作要部分地或者全部地退回去重做叫做<font color = red>回溯</font>

造成回溯的原因:文法中，对于<font color = red>某个非终结符号的规则其右部有多个选择</font>，并根据所面临的输入符号所不能准确地确定所要地选择时，就可能出现回溯。

回溯带来的后果：

严重的<font color = red>低效率</font>，只有理论上的意义而无实际意义

问题2：左递归

从左向右扫描源程序，同时实施最左推导。左递归文法会使自顶向下分析法陷入死循环。如果文法具有间接左递归，也将发生这个问题，只不过循环的圈子兜的更大。

# 二、文法的等价转化

* 非确定的自上而下分析法的困境和问题

  穷举试探地分析非常低效，因为选择产生式的不确定带来回溯问题并且无法处理左递归

* 自上而下分析的问题的解决方法

  * 消除文法的左递归
  * 克服回溯问题 

## 1.消除左递归

* 直接左递归：文法存在产生式A->Aα
* 间接左递归：文法不存在产生式A->Aα，但存在推导A=>Aα

（1）消除直接左递归的方法：

引入新的非终结符号A`，将关于A的如下产生式

![image-20200516230818136](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\image-20200516230818136.png)

​	（２）消除间接左递归

​		消除任何左递归的算法：
​		① 用代入法(分配律)将间接左递归变为直接左递归
​		② 按照消直接左递归的方法消除。

## 2.消除回溯

1.产生回溯的原因:同一非终结符有多个产生式

* 同一非终结符，其产生式左端第一个符号相同而引起回溯。
         	 例： Z→cAd          A→ab|a 

* 同一非终结符，其中某一右部能推出ε串，可能会引起回溯。

  ​			例：A->Bx		B->x |ε    =>		A->x| x x 	

2.<font color = red>消除回溯的途径:对具有多个右部的规则反复提取左因子</font>

3.提取公共因子的问题

* 提取公共左因子可能导致出现ε候选式

* 不能解决ε候选式不确定性问题

  * 如果ε是一个当前的候选式，匹配符号串的当前符号时，可以选择ε候选式，使当前符号与句型中在ε后面的符号匹配。

  * 但是如果当前的候选式的左边第一个符号，也有与符号串的当前符号的匹配的候选式，又要试探

* 一种不会出现上面问题的文法—LL(1)文法

# 三、LL(1)文法与递归下降子程序分析法

## 1.LL(1)文法特点

* 不含左递归
* 无需回溯

任意非终结符，其所有候选式都推出的第一个终结符不相同，即首符集互不相交

* 上面两个条件不能构成充分条件
* 对于文法中的非终结符A，有A→ε，还需要考查紧跟在A后的终结符，要避免回溯，A所推导的第一个终结符要和其后所跟的终结符相区别

> 对于这种文法，在推导过程可以根据当前的输入符号唯一确定选哪个产生式往下推导，即分析过程是确定的。

<font color = orange>LL(1)文法要求： G的任意两个具有相同左部的 产生式A→α|β满足下列条件：</font>

<font color = orange>（1）如果α，β均不能推导出ε，则First(α)∩First(β)=∅;</font>

<font color = orange>（2）α，β至多有一个能推导出ε；</font>

<font color = orange>（3）如果β能经过多步推导到ε，则First(α)∩Follow(A)=∅</font>

## 2.递归下降分析

### 2.1基本思想

对文法中的每个非终结符（语法成分）编写一个子程序，而子程序的代码结构由相应非终结符的产生式右部所决定：
产生式右部的终结符与输入符号相匹配
非终结符与相应的子程序调用对应 

### 2.2递归下降分析器的设计实例

见实验

### 2.3递归下降分析法的优缺点

优点：

* 构造方法非常简单
* 程序结构清晰

缺点：

* 递归调用较多，占用内存多、速度慢
* 如果所采用的高级语言不允许递归，则不能使用此方法

# 四、构建FIRST和FOLLOW集合

## 1.构建FIRST（首字符）集

（1）FIRST集合的定义

假定α是文法G的任一符号串，或α∈（Vt∪Vn），则：

FIRST（α）={a|a=>a...,a∈Vt}

若α=>ε，则规定ε∈FIRST（α）

FIRST(α)：从α可能推导出的所有开头终结符号或ε

应用：如果文法G中的所有A产生式为A->α1|α2|...|αm,且ε∉FIRST(α1)∪FIRST(α)∪...∪FIRST(α)，且对∀i,j, 1≤i，j≤m；i≠j，均有FIRST(αi)∩FIRST(αj)=Ø成立，则可以对G的句子进行确定的自顶向下分析

## 2.文法符号的FIRST集合构造方法

对于文法中的符号X∈Vn∪Vt，其FIRST(X)集合可反复应用下列规则计算，直到其FIRST(X)集合不再增大为止：

①若X∈Vt，则FIRST(X)={X}

②若X∈Vn，且具有形如X->aα的产生式（a∈Vt），或具有形如X->ε的产生式，则把a或ε加进FIRST(X)

③设G中有形如X->Y1Y2...Yk的产生式，

若Y1∈Vn，则把FIRST(Y1)中的一切非ε符号加进FIRST(X);

若ε∈FIRST(Y1),则将FIRSTY2)中的一切非ε的终结符加进FIRST(X)；
若ε∈FIRST(Y1)且ε∈FIRST(Y2),则将FIRST(X3)中的一切非ε的终结符加进FIRST(X)；
依此类推，若对于一切1≤i≤n,  ε∈FIRST(Yi)，则将ε加进FIRST(X)。

## 3.构建FOLLOW（后继符号）集合

如果存在A→ε这样的产生式，则需定义FOLLOW(A)
定义A的后续符号集为(∀A∈ＶT ) ： 

1. FOLLOW(A)={a|S =>αAaβ, a∈T, α,β∈(VN∪VT)*}
2. 如果A是某个句型的最右符号，则将结束符#  添加到FOLLOW(A)中

FOLLOW(A):是所有句型中紧接A之后的终结符号或#

应用：如果αj=>ε，则如果对∀i(1≤i≤m；i≠j)，FIRST(αi)∩FOLLOW(A)=Ø均成立，则可以对G的句子进行确定的自顶向下分析

## 4.构建FOLLOW集合的算法

1) 若A为开始符号，则把“#“ 加入 FOLLOW(A)中:#∈FOLLOW(E)

2) 若B→αAβ (β≠ε)，则把FIRST(β)-{ε}加入FOLLOW(A)

​		由F->(E)可知,)∈FOLLOW(E)

3)若B→αA或B→αAβ，且β=>ε，则把FOLLOW(B)加入到FOLLOW(A)中

# 五、LL(1)分析器工作原理

## 1.LL(1)分析器的基本思想

![image-20200519113428244](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\image-20200519113428244.png)

## 2.LL(1)分析器模型

LL(1)分析器由一个总控程序、一张分析表、一个分析栈和输入缓冲区组成

![image-20200519113704539](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\image-20200519113704539.png)

* <font color= red>**分析表M：是一个二维表，可用一个二维数组M[A，a]来表示，它指出了分析器应采取的动作。**</font>

  >1.分析表中的每一行是文法中的一个非终结符号、终结符号或#；
  >
  >2.分析表每一列是文法的一个终结符号或#。
  >
  >3.分析表的列数是终结符号的个数加1；
  >行数是非终结符号和终结符号的数目加1

## 3.LL(1)控制程序的工作过程

1.分析开始时，首先将符号#及文法的开始符号S依次置于分析栈的底部，并把各指示器调整至起始位置。然后，反复执行第二步的操作。 

2.假设分析的某一步，分析栈及余留的符号串，则根据栈顶的符号Xm，采取下列动作： 

![image-20200519114110910](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\image-20200519114110910.png)

# 六、LL(1)分析表构造算法

## 1.构造LL(1)分析表的基本思路

对于不同的LL(1)文法，LL(1)的分析算法是相同的，不同的仅仅是分析表

<font color = red>**如何根据文法来构造分析表LL(1)分析算法的关键!**</font>

基本思想：

当文法中某一非终结符出现在<font color = blue>栈顶</font>时，根据<font color = blue>当前的输入符号</font>，分析表应只是要用该终结符里的<font color = blue>那一条产生式规则（即进行下一步最左推导）</font>



# 2.LL(1)分析表的构建规则

(1) 首先，要求出每个非终结符号的FOLLOW集合和每个候选式的FIRST集合。

(2) 然后，对文法G中的每个产生式**A→α**，按下列规则确定分析表中的元素M： 

	 1)对FIRST(α)中的每个终结符a（即α 不是ε时），置M[A,a]=“POP，PUSH(α′)”或M[A，a]=“A→α” ，其中α′为α的倒置。
	 2)若ε∈FIRST(α)（即A→ε），则对属于FOLLOW(A)的每个符号b(b为终结符或#)，置M[A,b]=“POP”或M[A,b]=“A→ε” 。
	 3)把M中的所有M[a,a]置为“POP，NEXTSYM”， a∈VT ，置M[#,#]=“ ACCEPT”。（该项可以简化）
	 4)把M中所有不按上述规则定义的元素均置为空或“ERROR”。 
（3）分析表化简

* 当压栈的最后一个符号是终结符时，那么下一步的分析动作肯定是这个终极符号出栈。

## 3.预测分析表构建算法

算法1:预测分析表(LL(1)分析表)的构造算法。
输入：文法G;
输出：分析表M;
步骤：
1．对G中的任意一个产生式A→α, 执行第2步和第3步;
2． for ∀a∈FIRST(α), 将A→α填入M[A, a];
3． if ε∈FIRST(α) then ∀a属于FOLLOW(A),将A→ ε填入M[A, a];
	    if ε∈FIRST(α)&#∈FOLLOW(A) then将A→ ε填入M[A, #];
4．将所有无定义的M[A, b]标上出错标志。

# 七、自上而下语法分析小结

![image-20200519115532318](C:\Users\zxp\AppData\Roaming\Typora\typora-user-images\image-20200519115532318.png)

